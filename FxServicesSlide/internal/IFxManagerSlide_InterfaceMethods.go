// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/bhbosman/gocommon/internal/Services/UiSlides/FxServicesSlide/internal (interfaces: IFxManagerSlide)

// Package internal is a generated GoMock package.
package internal

import (
	"context"
	fmt "fmt"

	errors "github.com/bhbosman/gocommon/errors"
)

// Interface A Comment
// Interface github.com/bhbosman/gocommon/internal/Services/UiSlides/FxServicesSlide/internal
// Interface IFxManagerSlide
// Interface IFxManagerSlide, Method: StartAllService
type IFxManagerSlideStartAllServiceIn struct {
}

type IFxManagerSlideStartAllServiceOut struct {
}
type IFxManagerSlideStartAllServiceError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFxManagerSlideStartAllServiceError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFxManagerSlideStartAllService struct {
	inData         IFxManagerSlideStartAllServiceIn
	outDataChannel chan IFxManagerSlideStartAllServiceOut
}

func NewIFxManagerSlideStartAllService(waitToComplete bool) *IFxManagerSlideStartAllService {
	var outDataChannel chan IFxManagerSlideStartAllServiceOut
	if waitToComplete {
		outDataChannel = make(chan IFxManagerSlideStartAllServiceOut)
	} else {
		outDataChannel = nil
	}
	return &IFxManagerSlideStartAllService{
		inData:         IFxManagerSlideStartAllServiceIn{},
		outDataChannel: outDataChannel,
	}
}

func (self *IFxManagerSlideStartAllService) Wait(onError func(interfaceName string, methodName string, err error) error) (IFxManagerSlideStartAllServiceOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFxManagerSlideStartAllServiceError{
			InterfaceName: "IFxManagerSlide",
			MethodName:    "StartAllService",
			Reason:        "Channel for IFxManagerSlide::StartAllService returned false",
		}
		if onError != nil {
			err := onError("IFxManagerSlide", "StartAllService", generatedError)
			return IFxManagerSlideStartAllServiceOut{}, err
		} else {
			return IFxManagerSlideStartAllServiceOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFxManagerSlideStartAllService) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFxManagerSlideStartAllService(context context.Context, channel chan<- interface{}, waitToComplete bool) (IFxManagerSlideStartAllServiceOut, error) {
	if context != nil && context.Err() != nil {
		return IFxManagerSlideStartAllServiceOut{}, context.Err()
	}
	data := NewIFxManagerSlideStartAllService(waitToComplete)
	if waitToComplete {
		defer func(data *IFxManagerSlideStartAllService) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFxManagerSlideStartAllServiceOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFxManagerSlideStartAllServiceOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFxManagerSlideStartAllServiceOut{}, err
	}
	return v, nil
}

// Interface IFxManagerSlide, Method: StartService
type IFxManagerSlideStartServiceIn struct {
	arg0 string
}

type IFxManagerSlideStartServiceOut struct {
}
type IFxManagerSlideStartServiceError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFxManagerSlideStartServiceError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFxManagerSlideStartService struct {
	inData         IFxManagerSlideStartServiceIn
	outDataChannel chan IFxManagerSlideStartServiceOut
}

func NewIFxManagerSlideStartService(waitToComplete bool, arg0 string) *IFxManagerSlideStartService {
	var outDataChannel chan IFxManagerSlideStartServiceOut
	if waitToComplete {
		outDataChannel = make(chan IFxManagerSlideStartServiceOut)
	} else {
		outDataChannel = nil
	}
	return &IFxManagerSlideStartService{
		inData: IFxManagerSlideStartServiceIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IFxManagerSlideStartService) Wait(onError func(interfaceName string, methodName string, err error) error) (IFxManagerSlideStartServiceOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFxManagerSlideStartServiceError{
			InterfaceName: "IFxManagerSlide",
			MethodName:    "StartService",
			Reason:        "Channel for IFxManagerSlide::StartService returned false",
		}
		if onError != nil {
			err := onError("IFxManagerSlide", "StartService", generatedError)
			return IFxManagerSlideStartServiceOut{}, err
		} else {
			return IFxManagerSlideStartServiceOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFxManagerSlideStartService) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFxManagerSlideStartService(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 string) (IFxManagerSlideStartServiceOut, error) {
	if context != nil && context.Err() != nil {
		return IFxManagerSlideStartServiceOut{}, context.Err()
	}
	data := NewIFxManagerSlideStartService(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IFxManagerSlideStartService) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFxManagerSlideStartServiceOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFxManagerSlideStartServiceOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFxManagerSlideStartServiceOut{}, err
	}
	return v, nil
}

// Interface IFxManagerSlide, Method: StopAllService
type IFxManagerSlideStopAllServiceIn struct {
}

type IFxManagerSlideStopAllServiceOut struct {
}
type IFxManagerSlideStopAllServiceError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFxManagerSlideStopAllServiceError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFxManagerSlideStopAllService struct {
	inData         IFxManagerSlideStopAllServiceIn
	outDataChannel chan IFxManagerSlideStopAllServiceOut
}

func NewIFxManagerSlideStopAllService(waitToComplete bool) *IFxManagerSlideStopAllService {
	var outDataChannel chan IFxManagerSlideStopAllServiceOut
	if waitToComplete {
		outDataChannel = make(chan IFxManagerSlideStopAllServiceOut)
	} else {
		outDataChannel = nil
	}
	return &IFxManagerSlideStopAllService{
		inData:         IFxManagerSlideStopAllServiceIn{},
		outDataChannel: outDataChannel,
	}
}

func (self *IFxManagerSlideStopAllService) Wait(onError func(interfaceName string, methodName string, err error) error) (IFxManagerSlideStopAllServiceOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFxManagerSlideStopAllServiceError{
			InterfaceName: "IFxManagerSlide",
			MethodName:    "StopAllService",
			Reason:        "Channel for IFxManagerSlide::StopAllService returned false",
		}
		if onError != nil {
			err := onError("IFxManagerSlide", "StopAllService", generatedError)
			return IFxManagerSlideStopAllServiceOut{}, err
		} else {
			return IFxManagerSlideStopAllServiceOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFxManagerSlideStopAllService) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFxManagerSlideStopAllService(context context.Context, channel chan<- interface{}, waitToComplete bool) (IFxManagerSlideStopAllServiceOut, error) {
	if context != nil && context.Err() != nil {
		return IFxManagerSlideStopAllServiceOut{}, context.Err()
	}
	data := NewIFxManagerSlideStopAllService(waitToComplete)
	if waitToComplete {
		defer func(data *IFxManagerSlideStopAllService) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFxManagerSlideStopAllServiceOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFxManagerSlideStopAllServiceOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFxManagerSlideStopAllServiceOut{}, err
	}
	return v, nil
}

// Interface IFxManagerSlide, Method: StopService
type IFxManagerSlideStopServiceIn struct {
	arg0 string
}

type IFxManagerSlideStopServiceOut struct {
}
type IFxManagerSlideStopServiceError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFxManagerSlideStopServiceError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFxManagerSlideStopService struct {
	inData         IFxManagerSlideStopServiceIn
	outDataChannel chan IFxManagerSlideStopServiceOut
}

func NewIFxManagerSlideStopService(waitToComplete bool, arg0 string) *IFxManagerSlideStopService {
	var outDataChannel chan IFxManagerSlideStopServiceOut
	if waitToComplete {
		outDataChannel = make(chan IFxManagerSlideStopServiceOut)
	} else {
		outDataChannel = nil
	}
	return &IFxManagerSlideStopService{
		inData: IFxManagerSlideStopServiceIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IFxManagerSlideStopService) Wait(onError func(interfaceName string, methodName string, err error) error) (IFxManagerSlideStopServiceOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFxManagerSlideStopServiceError{
			InterfaceName: "IFxManagerSlide",
			MethodName:    "StopService",
			Reason:        "Channel for IFxManagerSlide::StopService returned false",
		}
		if onError != nil {
			err := onError("IFxManagerSlide", "StopService", generatedError)
			return IFxManagerSlideStopServiceOut{}, err
		} else {
			return IFxManagerSlideStopServiceOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFxManagerSlideStopService) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFxManagerSlideStopService(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 string) (IFxManagerSlideStopServiceOut, error) {
	if context != nil && context.Err() != nil {
		return IFxManagerSlideStopServiceOut{}, context.Err()
	}
	data := NewIFxManagerSlideStopService(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IFxManagerSlideStopService) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFxManagerSlideStopServiceOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFxManagerSlideStopServiceOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFxManagerSlideStopServiceOut{}, err
	}
	return v, nil
}

func ChannelEventsForIFxManagerSlide(next IFxManagerSlide, event interface{}) (bool, error) {
	switch v := event.(type) {
	case *IFxManagerSlideStartAllService:
		data := IFxManagerSlideStartAllServiceOut{}
		next.StartAllService()
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IFxManagerSlideStartService:
		data := IFxManagerSlideStartServiceOut{}
		next.StartService(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IFxManagerSlideStopAllService:
		data := IFxManagerSlideStopAllServiceOut{}
		next.StopAllService()
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IFxManagerSlideStopService:
		data := IFxManagerSlideStopServiceOut{}
		next.StopService(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	default:
		return false, nil
	}
}
