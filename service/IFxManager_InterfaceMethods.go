// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/bhbosman/goFxAppManager/service (interfaces: IFxManager)

// Package service is a generated GoMock package.
package service

import (
	context "context"
	fmt "fmt"

	errors "github.com/bhbosman/gocommon/errors"
	messages "github.com/bhbosman/gocommon/messages"
)

// Interface A Comment
// Interface github.com/bhbosman/goFxAppManager/service
// Interface IFxManager
// Interface IFxManager, Method: Add
type IFxManagerAddIn struct {
	arg0 string
	arg1 func() (messages.IApp, context.CancelFunc, error)
}

type IFxManagerAddOut struct {
	Args0 error
}
type IFxManagerAddError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFxManagerAddError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFxManagerAdd struct {
	inData         IFxManagerAddIn
	outDataChannel chan IFxManagerAddOut
}

func NewIFxManagerAdd(waitToComplete bool, arg0 string, arg1 func() (messages.IApp, context.CancelFunc, error)) *IFxManagerAdd {
	var outDataChannel chan IFxManagerAddOut
	if waitToComplete {
		outDataChannel = make(chan IFxManagerAddOut)
	} else {
		outDataChannel = nil
	}
	return &IFxManagerAdd{
		inData: IFxManagerAddIn{
			arg0: arg0,
			arg1: arg1,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IFxManagerAdd) Wait(onError func(interfaceName string, methodName string, err error) error) (IFxManagerAddOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFxManagerAddError{
			InterfaceName: "IFxManager",
			MethodName:    "Add",
			Reason:        "Channel for IFxManager::Add returned false",
		}
		if onError != nil {
			err := onError("IFxManager", "Add", generatedError)
			return IFxManagerAddOut{}, err
		} else {
			return IFxManagerAddOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFxManagerAdd) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFxManagerAdd(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 string, arg1 func() (messages.IApp, context.CancelFunc, error)) (IFxManagerAddOut, error) {
	if context != nil && context.Err() != nil {
		return IFxManagerAddOut{}, context.Err()
	}
	data := NewIFxManagerAdd(waitToComplete, arg0, arg1)
	if waitToComplete {
		defer func(data *IFxManagerAdd) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFxManagerAddOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFxManagerAddOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFxManagerAddOut{}, err
	}
	return v, nil
}

// Interface IFxManager, Method: GetState
type IFxManagerGetStateIn struct {
}

type IFxManagerGetStateOut struct {
	Args0 []string
	Args1 error
}
type IFxManagerGetStateError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFxManagerGetStateError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFxManagerGetState struct {
	inData         IFxManagerGetStateIn
	outDataChannel chan IFxManagerGetStateOut
}

func NewIFxManagerGetState(waitToComplete bool) *IFxManagerGetState {
	var outDataChannel chan IFxManagerGetStateOut
	if waitToComplete {
		outDataChannel = make(chan IFxManagerGetStateOut)
	} else {
		outDataChannel = nil
	}
	return &IFxManagerGetState{
		inData:         IFxManagerGetStateIn{},
		outDataChannel: outDataChannel,
	}
}

func (self *IFxManagerGetState) Wait(onError func(interfaceName string, methodName string, err error) error) (IFxManagerGetStateOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFxManagerGetStateError{
			InterfaceName: "IFxManager",
			MethodName:    "GetState",
			Reason:        "Channel for IFxManager::GetState returned false",
		}
		if onError != nil {
			err := onError("IFxManager", "GetState", generatedError)
			return IFxManagerGetStateOut{}, err
		} else {
			return IFxManagerGetStateOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFxManagerGetState) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFxManagerGetState(context context.Context, channel chan<- interface{}, waitToComplete bool) (IFxManagerGetStateOut, error) {
	if context != nil && context.Err() != nil {
		return IFxManagerGetStateOut{}, context.Err()
	}
	data := NewIFxManagerGetState(waitToComplete)
	if waitToComplete {
		defer func(data *IFxManagerGetState) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFxManagerGetStateOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFxManagerGetStateOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFxManagerGetStateOut{}, err
	}
	return v, nil
}

// Interface IFxManager, Method: Publish
type IFxManagerPublishIn struct {
}

type IFxManagerPublishOut struct {
	Args0 error
}
type IFxManagerPublishError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFxManagerPublishError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFxManagerPublish struct {
	inData         IFxManagerPublishIn
	outDataChannel chan IFxManagerPublishOut
}

func NewIFxManagerPublish(waitToComplete bool) *IFxManagerPublish {
	var outDataChannel chan IFxManagerPublishOut
	if waitToComplete {
		outDataChannel = make(chan IFxManagerPublishOut)
	} else {
		outDataChannel = nil
	}
	return &IFxManagerPublish{
		inData:         IFxManagerPublishIn{},
		outDataChannel: outDataChannel,
	}
}

func (self *IFxManagerPublish) Wait(onError func(interfaceName string, methodName string, err error) error) (IFxManagerPublishOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFxManagerPublishError{
			InterfaceName: "IFxManager",
			MethodName:    "Publish",
			Reason:        "Channel for IFxManager::Publish returned false",
		}
		if onError != nil {
			err := onError("IFxManager", "Publish", generatedError)
			return IFxManagerPublishOut{}, err
		} else {
			return IFxManagerPublishOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFxManagerPublish) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFxManagerPublish(context context.Context, channel chan<- interface{}, waitToComplete bool) (IFxManagerPublishOut, error) {
	if context != nil && context.Err() != nil {
		return IFxManagerPublishOut{}, context.Err()
	}
	data := NewIFxManagerPublish(waitToComplete)
	if waitToComplete {
		defer func(data *IFxManagerPublish) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFxManagerPublishOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFxManagerPublishOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFxManagerPublishOut{}, err
	}
	return v, nil
}

// Interface IFxManager, Method: Send
type IFxManagerSendIn struct {
	arg0 interface{}
}

type IFxManagerSendOut struct {
	Args0 error
}
type IFxManagerSendError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFxManagerSendError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFxManagerSend struct {
	inData         IFxManagerSendIn
	outDataChannel chan IFxManagerSendOut
}

func NewIFxManagerSend(waitToComplete bool, arg0 interface{}) *IFxManagerSend {
	var outDataChannel chan IFxManagerSendOut
	if waitToComplete {
		outDataChannel = make(chan IFxManagerSendOut)
	} else {
		outDataChannel = nil
	}
	return &IFxManagerSend{
		inData: IFxManagerSendIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IFxManagerSend) Wait(onError func(interfaceName string, methodName string, err error) error) (IFxManagerSendOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFxManagerSendError{
			InterfaceName: "IFxManager",
			MethodName:    "Send",
			Reason:        "Channel for IFxManager::Send returned false",
		}
		if onError != nil {
			err := onError("IFxManager", "Send", generatedError)
			return IFxManagerSendOut{}, err
		} else {
			return IFxManagerSendOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFxManagerSend) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFxManagerSend(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 interface{}) (IFxManagerSendOut, error) {
	if context != nil && context.Err() != nil {
		return IFxManagerSendOut{}, context.Err()
	}
	data := NewIFxManagerSend(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IFxManagerSend) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFxManagerSendOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFxManagerSendOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFxManagerSendOut{}, err
	}
	return v, nil
}

// Interface IFxManager, Method: Start
type IFxManagerStartIn struct {
	arg0 context.Context
	arg1 []string
}

type IFxManagerStartOut struct {
	Args0 error
}
type IFxManagerStartError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFxManagerStartError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFxManagerStart struct {
	inData         IFxManagerStartIn
	outDataChannel chan IFxManagerStartOut
}

func NewIFxManagerStart(waitToComplete bool, arg0 context.Context, arg1 ...string) *IFxManagerStart {
	var outDataChannel chan IFxManagerStartOut
	if waitToComplete {
		outDataChannel = make(chan IFxManagerStartOut)
	} else {
		outDataChannel = nil
	}
	return &IFxManagerStart{
		inData: IFxManagerStartIn{
			arg0: arg0,
			arg1: arg1,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IFxManagerStart) Wait(onError func(interfaceName string, methodName string, err error) error) (IFxManagerStartOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFxManagerStartError{
			InterfaceName: "IFxManager",
			MethodName:    "Start",
			Reason:        "Channel for IFxManager::Start returned false",
		}
		if onError != nil {
			err := onError("IFxManager", "Start", generatedError)
			return IFxManagerStartOut{}, err
		} else {
			return IFxManagerStartOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFxManagerStart) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFxManagerStart(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 context.Context, arg1 ...string) (IFxManagerStartOut, error) {
	if context != nil && context.Err() != nil {
		return IFxManagerStartOut{}, context.Err()
	}
	data := NewIFxManagerStart(waitToComplete, arg0, arg1...)
	if waitToComplete {
		defer func(data *IFxManagerStart) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFxManagerStartOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFxManagerStartOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFxManagerStartOut{}, err
	}
	return v, nil
}

// Interface IFxManager, Method: StartAll
type IFxManagerStartAllIn struct {
	arg0 context.Context
}

type IFxManagerStartAllOut struct {
	Args0 error
}
type IFxManagerStartAllError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFxManagerStartAllError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFxManagerStartAll struct {
	inData         IFxManagerStartAllIn
	outDataChannel chan IFxManagerStartAllOut
}

func NewIFxManagerStartAll(waitToComplete bool, arg0 context.Context) *IFxManagerStartAll {
	var outDataChannel chan IFxManagerStartAllOut
	if waitToComplete {
		outDataChannel = make(chan IFxManagerStartAllOut)
	} else {
		outDataChannel = nil
	}
	return &IFxManagerStartAll{
		inData: IFxManagerStartAllIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IFxManagerStartAll) Wait(onError func(interfaceName string, methodName string, err error) error) (IFxManagerStartAllOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFxManagerStartAllError{
			InterfaceName: "IFxManager",
			MethodName:    "StartAll",
			Reason:        "Channel for IFxManager::StartAll returned false",
		}
		if onError != nil {
			err := onError("IFxManager", "StartAll", generatedError)
			return IFxManagerStartAllOut{}, err
		} else {
			return IFxManagerStartAllOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFxManagerStartAll) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFxManagerStartAll(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 context.Context) (IFxManagerStartAllOut, error) {
	if context != nil && context.Err() != nil {
		return IFxManagerStartAllOut{}, context.Err()
	}
	data := NewIFxManagerStartAll(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IFxManagerStartAll) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFxManagerStartAllOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFxManagerStartAllOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFxManagerStartAllOut{}, err
	}
	return v, nil
}

// Interface IFxManager, Method: Stop
type IFxManagerStopIn struct {
	arg0 context.Context
	arg1 []string
}

type IFxManagerStopOut struct {
	Args0 error
}
type IFxManagerStopError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFxManagerStopError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFxManagerStop struct {
	inData         IFxManagerStopIn
	outDataChannel chan IFxManagerStopOut
}

func NewIFxManagerStop(waitToComplete bool, arg0 context.Context, arg1 ...string) *IFxManagerStop {
	var outDataChannel chan IFxManagerStopOut
	if waitToComplete {
		outDataChannel = make(chan IFxManagerStopOut)
	} else {
		outDataChannel = nil
	}
	return &IFxManagerStop{
		inData: IFxManagerStopIn{
			arg0: arg0,
			arg1: arg1,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IFxManagerStop) Wait(onError func(interfaceName string, methodName string, err error) error) (IFxManagerStopOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFxManagerStopError{
			InterfaceName: "IFxManager",
			MethodName:    "Stop",
			Reason:        "Channel for IFxManager::Stop returned false",
		}
		if onError != nil {
			err := onError("IFxManager", "Stop", generatedError)
			return IFxManagerStopOut{}, err
		} else {
			return IFxManagerStopOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFxManagerStop) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFxManagerStop(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 context.Context, arg1 ...string) (IFxManagerStopOut, error) {
	if context != nil && context.Err() != nil {
		return IFxManagerStopOut{}, context.Err()
	}
	data := NewIFxManagerStop(waitToComplete, arg0, arg1...)
	if waitToComplete {
		defer func(data *IFxManagerStop) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFxManagerStopOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFxManagerStopOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFxManagerStopOut{}, err
	}
	return v, nil
}

// Interface IFxManager, Method: StopAll
type IFxManagerStopAllIn struct {
	arg0 context.Context
}

type IFxManagerStopAllOut struct {
	Args0 error
}
type IFxManagerStopAllError struct {
	InterfaceName string
	MethodName    string
	Reason        string
}

func (self *IFxManagerStopAllError) Error() string {
	return fmt.Sprintf("error in data coming back from %v::%v. Reason: %v", self.InterfaceName, self.MethodName, self.Reason)
}

type IFxManagerStopAll struct {
	inData         IFxManagerStopAllIn
	outDataChannel chan IFxManagerStopAllOut
}

func NewIFxManagerStopAll(waitToComplete bool, arg0 context.Context) *IFxManagerStopAll {
	var outDataChannel chan IFxManagerStopAllOut
	if waitToComplete {
		outDataChannel = make(chan IFxManagerStopAllOut)
	} else {
		outDataChannel = nil
	}
	return &IFxManagerStopAll{
		inData: IFxManagerStopAllIn{
			arg0: arg0,
		},
		outDataChannel: outDataChannel,
	}
}

func (self *IFxManagerStopAll) Wait(onError func(interfaceName string, methodName string, err error) error) (IFxManagerStopAllOut, error) {
	data, ok := <-self.outDataChannel
	if !ok {
		generatedError := &IFxManagerStopAllError{
			InterfaceName: "IFxManager",
			MethodName:    "StopAll",
			Reason:        "Channel for IFxManager::StopAll returned false",
		}
		if onError != nil {
			err := onError("IFxManager", "StopAll", generatedError)
			return IFxManagerStopAllOut{}, err
		} else {
			return IFxManagerStopAllOut{}, generatedError
		}
	}
	return data, nil
}

func (self *IFxManagerStopAll) Close() error {
	close(self.outDataChannel)
	return nil
}
func CallIFxManagerStopAll(context context.Context, channel chan<- interface{}, waitToComplete bool, arg0 context.Context) (IFxManagerStopAllOut, error) {
	if context != nil && context.Err() != nil {
		return IFxManagerStopAllOut{}, context.Err()
	}
	data := NewIFxManagerStopAll(waitToComplete, arg0)
	if waitToComplete {
		defer func(data *IFxManagerStopAll) {
			err := data.Close()
			if err != nil {
			}
		}(data)
	}
	if context != nil && context.Err() != nil {
		return IFxManagerStopAllOut{}, context.Err()
	}
	channel <- data
	var err error
	var v IFxManagerStopAllOut
	if waitToComplete {
		v, err = data.Wait(func(interfaceName string, methodName string, err error) error {
			return err
		})
	} else {
		err = errors.NoWaitOperationError
	}
	if err != nil {
		return IFxManagerStopAllOut{}, err
	}
	return v, nil
}

func ChannelEventsForIFxManager(next IFxManager, event interface{}) (bool, error) {
	switch v := event.(type) {
	case *IFxManagerAdd:
		data := IFxManagerAddOut{}
		data.Args0 = next.Add(v.inData.arg0, v.inData.arg1)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IFxManagerGetState:
		data := IFxManagerGetStateOut{}
		data.Args0, data.Args1 = next.GetState()
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IFxManagerPublish:
		data := IFxManagerPublishOut{}
		data.Args0 = next.Publish()
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IFxManagerSend:
		data := IFxManagerSendOut{}
		data.Args0 = next.Send(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IFxManagerStart:
		data := IFxManagerStartOut{}
		data.Args0 = next.Start(v.inData.arg0, v.inData.arg1...)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IFxManagerStartAll:
		data := IFxManagerStartAllOut{}
		data.Args0 = next.StartAll(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IFxManagerStop:
		data := IFxManagerStopOut{}
		data.Args0 = next.Stop(v.inData.arg0, v.inData.arg1...)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	case *IFxManagerStopAll:
		data := IFxManagerStopAllOut{}
		data.Args0 = next.StopAll(v.inData.arg0)
		if v.outDataChannel != nil {
			v.outDataChannel <- data
		}
		return true, nil
	default:
		return false, nil
	}
}
